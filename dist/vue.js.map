{"version":3,"file":"vue.js","sources":["../src/compile/generate.js","../src/compile/parser.js","../src/compile/index.js","../src/vdom/index.js","../src/vdom/patch.js","../src/observer/dep.js","../src/observer/watcher.js","../src/lifecycle.js","../src/observer/array.js","../src/observer/index.js","../src/state.js","../src/utils.js","../src/init.js","../src/initGlobalAPI/index.js","../src/index.js"],"sourcesContent":["const defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g // {{  asdasd  }}\n\nfunction genProps(attrs) {\n    let str = '';\n    for (let i = 0; i < attrs.length; i++) {\n        let attr = attrs[i];\n        if (attr.name === 'style') {\n            let style = {} // color:red;background:blue\n            attr.value.replace(/([^;:]+)\\:([^;:]+)/g, function() {\n                style[arguments[1]] = arguments[2]\n            }); // 如果是sytle 我要将style转换成一个对象\n            attr.value = style;\n        }\n        str += `${attr.name}:${JSON.stringify(attr.value)},`\n    }\n    return `{${str.slice(0,-1)}}`\n}\n\nfunction gen(el) {\n    if (el.type == 1) {\n        return generate(el)\n    } else {\n        let text = el.text\n        if (!defaultTagRE.test(text)) {\n            return `_v(\"${text}\")`\n        } else {  \n            let tokens = []; // 杨帅 {{age}} 杨帅\n            // _v(_s(name) + '杨帅' + _s(age))\n            let match;\n            let lastIndex = defaultTagRE.lastIndex = 0; // 保证每次正则都是从0 开始匹配的\n            while (match = defaultTagRE.exec(text)) { // 如果exec + 全局匹配每次执行的时候 都需要还原lastIndex\n                let index = match.index; // 匹配到后将前面一段放到tokens中\n                if (index > lastIndex) {\n                    tokens.push(JSON.stringify(text.slice(lastIndex, index)))\n                }\n                tokens.push(`_s(${match[1].trim()})`);   // 把当前这一段放到tokens中\n                lastIndex = index + match[0].length\n            }\n            if(lastIndex < text.length){\n                tokens.push(JSON.stringify(text.slice(lastIndex)))\n            }\n            return `_v(${tokens.join('+')})`\n        }\n    }\n}\n\n\nfunction genChildren(ast) {\n    let children = ast.children; // _c('div',{},'xxx')  _c('div',{},[])\n    if (children && children.length > 0) {\n        return children.map(child => gen(child)).join(',')\n    }\n    return false;\n}\nexport function generate(ast) {\n    let children = genChildren(ast)\n    let code = `_c(\"${ast.tag}\",${\n        ast.attrs.length? genProps(ast.attrs) : 'undefined'\n    }${\n        children? ',['+children+']' : ''\n    })`\n    return code;\n}\n\n// _c('div', {\n//     \"id\": \"app\",\n//     \"a\": \"1\",\n//     \"b\": \"2\",\n// }, [_v(\"hello\" + _s(age) + \"\\n        \"), _c('span', [_v(_s(name))])])","const ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; //\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; //  match匹配的是标签名\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 \nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的 分组里放的就是 \"b\",'b' ,b  => (b) 3 | 4 | 5\n\n\n// a = \"b\"   a = 'b'   a = b\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 <br/>   <div> \nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g // {{  asdasd  }}\n\n\nexport function parserHTML(html) {\n    function advance(len) {\n        html = html.substring(len);\n    }\n\n    function parseStartTag() {\n        const start = html.match(startTagOpen);\n        if (start) {\n            const match = {\n                tagName: start[1],\n                attrs: []\n            }\n            advance(start[0].length);\n            let attr;\n            let end;\n            while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n                match.attrs.push({ name: attr[1], value: attr[3] || attr[4] || attr[5] });\n                advance(attr[0].length);\n            }\n            advance(end[0].length);\n            return match;\n        }\n        return false;\n\n    }\n    // 生成一颗树  <div id=\"app\" a=1 b=2>hello{{age}} <span>{{name}}</p>111</div>\n    // [div,span]\n    // 文本 -》 我的父亲是div\n    // span => 我的父亲是div\n    // {{name}} => 我的父亲是span\n    // 遇到结束标签 就做pop操作 [div]\n    // 111 -> 我的父亲是div\n    //  就做pop操作\n    let root = null;\n    let stack = [];\n    let parent = null;\n    function createAstElement(tag, attrs) {\n        return {\n            tag,\n            type: 1,\n            attrs,\n            children: [],\n            parent: null\n        }\n    }\n    function start(tagName, attrs) { // 匹配到了开始的标签\n        let element = createAstElement(tagName, attrs);\n        if (!root) {\n            root = element\n        }\n        let parent = stack[stack.length - 1];\n        if (parent) {\n            element.parent = parent; // 当放入span的时候 我就知道div是他的父亲\n            parent.children.push(element);\n        }\n        stack.push(element);\n    }\n    function chars(text) { // 匹配到了开始的标签\n        let parent = stack[stack.length - 1];\n        text = text.replace(/\\s/g,''); // 遇到空格就删除掉\n        if(text){\n            parent.children.push({\n                text,\n                type:3\n            });\n        }\n    }\n    function end(tagName) {\n        stack.pop(); // 每次出去就在栈中删除当前这一项, 这里你可以判断标签是否出错\n    }\n    while (html) { // html只能由一个根节点\n        let textEnd = html.indexOf('<');\n        if (textEnd == 0) { // 如果遇到< 说明可能是开始标签或者结束标签 <!DOC\n            const startTagMatch = parseStartTag();\n            // console.log(startTagMatch)\n            if (startTagMatch) { // 匹配到了开始标签\n                start(startTagMatch.tagName, startTagMatch.attrs);\n                continue\n            }\n            // 如果代码走到这里了 说明是结束标签\n            const endTagMatch = html.match(endTag);\n            if (endTagMatch) {\n                end(endTagMatch[1]);\n                advance(endTagMatch[0].length);\n            }\n        }\n        let text;\n        if (textEnd > 0) {\n            text = html.substring(0, textEnd)\n        }\n        if (text) {\n            chars(text);\n            advance(text.length);\n        }\n    }\n    return root;\n}\n\n// 虚拟dom是描述dom的对象\n{ /*  <span>{{name}}</span></div> */ }\n\n// ast 抽象语法树 ，描述html语法本身的\n\n// {\n//     tag:'div',\n//     type:1,\n//     children:[{text:'hello {{age}}',type:3,parent:'div对象'},{ type:'span',type:1,attrs:[],parent:'div对象'}]\n//     attrs:[{name:'id':value:'app'}],\n//     parent:null\n// }","import { generate } from \"./generate\";\nimport { parserHTML } from \"./parser\";\n\nexport function compileToFunction(html) {\n    // 编译流程有三个部分 1.把模板变成ast语法树   2.优化标记静态节点 （patchFlag,BlockTree） 3.把ast变成render函数\n    const ast = parserHTML(html);\n    // console.log(ast);\n    \n    // 2.优化标记静态节点\n\n\n    // 3.将ast变成render函数  你要把刚才这棵树 用字符串拼接的方式 变成render函数\n    const code = generate(ast); // 根据ast生成一个代码字符串\n\n    const render = new Function(`with(this){return ${code}}`);\n    return render;\n}\n\n\n// 第一种 一个个的进行词法解析 <  {  （状态机 随着状态的扭转把结果进行解析） Vue3\n// 第二种 采用的是正则\n// <div id=\"app\">hello{{age}}</div>","export function createElement(vm,tag, props = {}, children) {\n    return vnode(vm, tag, props, children,undefined, props.key)\n}\n\nexport function createTextElement(vm,text) {\n    return vnode(vm, undefined, undefined, undefined, text)\n}\n\nexport function isSameVnode(oldVnode, newVnode) {\n  return oldVnode.tag == newVnode.tag && oldVnode.key === newVnode.key;\n}\n\nfunction vnode(vm, tag, props, children, text, key) {\n    return {\n        vm,\n        tag,\n        props,\n        children,\n        text,\n        key\n    }\n}","import { isSameVnode } from \".\";\n\nexport function patch(oldVnode, vnode) {\n  if (oldVnode.nodeType === 1) {\n    // 初始化渲染操作\n    // 根据虚拟节点创造真实节点, 先根据虚拟节点创建一个真实节点，将节点插入到页面中在将老节点删除 \n    // 为什么$mount('body | html')\n    const parentElm = oldVnode.parentNode; // 获取父元素\n    const elm = createElm(vnode)\n    // 直接扔到body里不行吗？\n    parentElm.insertBefore(elm, oldVnode.nextSibling)\n    parentElm.removeChild(oldVnode);\n\n    return elm;\n  } else {\n    // oldVnode 是虚拟节点，代表要做新旧 vnode 的 diff\n    // -------------- diff 来啦 -----------------\n    // 比较虚拟节点的差异，而且会递归下探到子节点\n    patchVnode(oldVnode, vnode);\n    \n    return vnode.el; // 最终返回新的 el 元素\n  }\n}\n\n\n// 新旧 vnode 的 diff 比对\nfunction patchVnode(oldVnode, vnode) {\n  // 1. 节点改变直接替换\n  if (!isSameVnode(oldVnode, vnode)) {\n    // 如果顶层节点不能复用，不用进行 diff 算法比对，newVnode -> newDom -> 替换旧 DOM\n    return oldVnode.el.parentNode.replaceChild(createElm(vnode), oldVnode.el)\n  }\n\n  // 复用 el\n  let el = vnode.el = oldVnode.el;\n\n  // 2. 文本节点直接替换(tag 为 undefined)\n  if (!oldVnode.tag) {\n    // 因为走到这里说明新旧节点相等(一个为 undefined，另一个也是)，不然在 1 就被替换啦，所以这里判断一个即可\n    if (oldVnode.text !== vnode.text) {\n      return oldVnode.el.textContent = vnode.text;\n    }\n  }\n\n  // 3. 相同节点，对比 & 更新属性\n  updateProperties(vnode, oldVnode.props);\n\n  // 比对完外部标签后，该进行儿子的比对了\n  //  @1 两方都有儿子\n  //  @2 一方有儿子，一方没儿子\n  //  @3 两方都是文本的\n  let oldChildren = oldVnode.children || [];\n  let newChildren = vnode.children || [];\n\n  if (oldChildren.length > 0 && newChildren.length > 0) {\n    // 两方都有儿子(可能是文本哦)，开始进行 diff 比对\n    updateChildren(el, oldChildren, newChildren);\n  } else if (oldChildren.length > 0) {\n    // 老节点有儿子，新节点没儿子，给复用的节点干掉子节点\n    el.innerHTML = '';\n  } else if (newChildren.length > 0) {\n    // 新节点有儿子，老节点没儿子, 给复用的节点创建儿子\n    newChildren.forEach(child => el.appendChild(createElm(child)));\n  }\n}\n\n// 比较儿子节点，diff 算法的核心\nfunction updateChildren(el, oldChildren, newChildren) {\n  // vue2 对常见dom的操作做了一些优化\n  // push shift unshift pop reserver sort api经常被用到，我们就考虑对这些特殊的情况做一些优化\n  // 内部采用了双指针的方式\n  let oldStartIndex = 0;\n  let newStartIndex = 0;\n  let oldEndIndex = oldChildren.length - 1;\n  let newEndIndex = newChildren.length - 1; // 索引 \n  // 当前虚拟节点\n  let oldStartVnode = oldChildren[oldStartIndex];\n  let newStartVnode = newChildren[newStartIndex];\n  let oldEndVnode = oldChildren[oldEndIndex];\n  let newEndVnode = newChildren[newEndIndex] // 虚拟节点\n\n  function makeIndexByKey(oldChildren) {\n    let map = {};\n\n    oldChildren.forEach((item, index) => {\n      map[item.key] = index;\n    });\n\n    return map;\n  }\n\n  // 将旧 children 做出映射表, ABCD -> {A: 0, B: 1, C: 2, D: 3}\n  let map = makeIndexByKey(oldChildren);\n\n  // 从头部开始比，比对结束后移动指针，一方遍历结束 O(n) 的遍历\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    if (!oldStartVnode) {\n      // 防止指针在移动的时候 oldChildren 中的那一项已经被移动走了(重置为 null)，则直接跳过 \n      // 比如 ABCDEF -> BDEMP，当遍历到新列表中 D 时候，就把 ABCDEF -> ABC null EF 了。\n      // 那么老列表遍历到 null 要直接跳到下一个！\n      // 同样后面元素往前移动也需要跳过去(比如移动到某节点前)，如果该节点为null，不处理\n      oldStartVnode = oldChildren[++oldStartIndex]\n    } else if (!oldEndVnode) {\n      // 防止指针在移动的时候 oldChildren 中的那一项已经被移动走了(重置为 null)，则直接跳过\n      oldEndVnode = oldChildren[--oldEndIndex]\n    } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n      // 旧 children 头节点相同，继续比头节点\n\n      // 相同节点直接递归 diff 比对 + 节点更新，标签一致比属性，属性比完比儿子\n      patchVnode(oldStartVnode, newStartVnode);\n\n      // 移动指针，继续遍历\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newStartVnode = newChildren[++newStartIndex];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      // 新旧 children 头节点不同，尾结点相同\n\n      // 节点 diff\n      patchVnode(oldEndVnode, newEndVnode);\n\n      // 修改下标，继续遍历\n      oldEndVnode = oldChildren[--oldEndIndex];\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      // 头和头，尾和尾都不同，旧 children 头和新 children 尾相同，头真实 dom 移到尾部\n\n      // 节点 diff\n      patchVnode(oldStartVnode, newEndVnode);\n\n      // 元素移位，移动到旧 children 末尾的后面\n      el.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling);\n\n      // 更新旧 children 的开始节点为下一个，且进行指针移动\n      oldStartVnode = oldChildren[++oldStartIndex];\n      // 更新新 children 的尾节点为前一个，且进行指针移动\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      // 头和头，尾和尾都不同，旧 children 尾和新 children 头相同，尾移头\n\n      // 节点 diff\n      patchVnode(oldEndVnode, newStartVnode);\n\n      // 元素移位，移动到旧 children 开始节点的前面\n      el.insertBefore(oldEndVnode.el, oldStartVnode.el);\n\n      // 更新旧 children 的尾节点为前一个，且进行指针移动\n      oldEndVnode = oldChildren[--oldEndIndex];\n      // 更新新 children 的尾节点为前一个，且进行指针移动\n      newStartVnode = newChildren[++newStartIndex];\n    } else { // 搞完四种特殊场景的优化后，我们需要来最复杂的乱序比对啦\n      // 乱序比对是指，以上四种情况都不满足，头头，头尾互相都不等\n\n      // 拿到当前新 children 中节点的 key 去 map 中寻找，找到代表需要进行真实 dom 移位\n      // 当然，列表上也要移位，原位置补 null，为了保下标\n      let moveIndex = map[newStartVnode.key];\n\n      if (moveIndex === undefined) { // 老列表不存在，创建 dom 节点，插入到 oldStartIndex 前面\n        el.insertBefore(createElm(newStartVnode), oldStartVnode.el);\n      } else {  // 比较并移动\n        let moveVnode = oldChildren[moveIndex]; // 获取要移动的虚拟节点\n\n        // 能复用就要比对，更新属性和子节点等~\n        patchVnode(moveVnode, newStartVnode);\n        el.insertBefore(moveVnode.el, oldStartVnode.el); // 将更新过的真实节点移动出来\n        oldChildren[moveIndex] = null; // 列表上把移走的元素置 null\n      }\n\n      // 移动到下一个节点做比对，可以理解成这里面不停遍历新列表\n      newStartVnode = newChildren[++newStartIndex];\n    }\n  }\n\n  // 乱序比对完成，把剩余没操作的元素干掉\n  if (oldStartIndex <= oldEndIndex) {\n    for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n      let child = oldChildren[i];\n\n      if (child !== null) {\n        el.removeChild(child.el); // 移除老的中心的不需要的元素\n      }\n    }\n  }\n\n  // 针对节点不同的更新情况~\n  // 如果是后面或前面追加元素\n  //   @1 比如 ABCD -> ABCDEF，需要把尾部新增元素插入\n  //   @2 比如 EABCD -> ABCD，需要把头部新增元素插入\n  // 具体做法是取尾指针的下一个元素\n  //   @2 如果没值，说明尾指针在末尾(后追加元素)，对整个列表进行元素追加即可\n  //   @1 如果有值，说明尾指针在前面了(前追加元素)，做下个节点的前插入\n  if (newStartIndex <= newEndIndex) {\n    for (let i = newStartIndex; i <= newEndIndex; i++) {\n      // 尾指针的下一个元素！也是参考物，有就是插入，没有就是追加\n      let anchor = newChildren[newEndIndex + 1] == null ? null : newChildren[newEndIndex + 1].el;\n\n      el.insertBefore(createElm(newChildren[i]), anchor);\n    }\n  }\n}\n\n// 相同节点，对比 & 更新属性，oldProps 首次渲染不存在\nfunction updateProperties(vnode, oldProps = {}) { // oldProps 可能不存在，如果存在就表示更新\n  let newProps = vnode.props || {}; // 获取新的属性\n  let el = vnode.el;\n  // 比较前后属性是否一致 老的有新的没有，将老的删除掉，\n  // 如果新的有 老的 也有，以新的为准\n  // 如果新的有老的没有，直接替换成新的\n  let oldStyle = oldProps.style || {}; // 如果前后都是样式\n  let newStyle = newProps.style || {};\n  for (let key in oldStyle) {\n    if (!(key in newStyle)) { // 老的有的属性 但是新的没有，我就将他移除掉 \n      el.style[key] = ''\n    }\n  }\n  for (let key in oldProps) {\n    if (!(key in newProps)) { // 老的有的属性 但是新的没有，我就将他移除掉 \n      el.removeAttribute(key)\n    }\n  }\n  for (let key in newProps) { // 以新的为准\n    if (key == 'style') {\n      for (let styleName in newStyle) {\n        el.style[styleName] = newStyle[styleName]; // 对样式的特殊处理\n      }\n    } else {\n      el.setAttribute(key, newProps[key]);\n    }\n  }\n}\n\nexport function createElm(vnode) {\n  const { tag, props, children, text } = vnode;\n  if (typeof tag == 'string') {\n    vnode.el = document.createElement(tag); // 把创建的真实dom和虚拟dom映射在一起方便后续更新和复用\n    updateProperties(vnode); // 处理样式\n    children && children.forEach(child => {\n      vnode.el.appendChild(createElm(child))\n    });\n    // 样式稍后处理  diff算法的时候需要比较新老的属性进行更新？？？？？？\n  } else {\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el;\n}","let id = 0;\n\n// 默认收集依赖调用的是dep.depend方法 核心就是让dep和watcher产生关联\n// 我要记住这个属性依赖了哪个watcher，等会数据变化我要知道哪个watcher要更新了\n// 还要记住watcher对应了那些属性 ...\nclass Dep{\n    constructor() {\n        this.id = id++;\n        this.subs = [];\n    }\n    depend(){\n        Dep.target.addDep(this); // 让watcher记住dep，同时去重\n        // this.subs.push(Dep.target); // 直接让属性记住watcher？\n    }\n    addSub(watcher){\n        this.subs.push(watcher);\n    }\n    notify(){\n        this.subs.forEach(watcher=>watcher.update());\n    }\n}\nDep.target = null;\n\nexport default Dep; // 每个对象都增加一个dep ， 每个属性都增加一个dep","let id = 0;\nimport Dep from './dep';\nclass Watcher {\n    // 用户的回调 是用户的函数  \n    // exprOrFn: 可能是个表达式(计算属性)或者更新的函数(vm._update(vm._render()))或字符串(watch 创建的 watcher)\n    // vm 是当前的实例  \n    // options 就是参数列表\n    constructor(vm,exprOrFn,callback,options = {}) {\n        this.deps = []; // watcher对应存放的dep\n        this.id = id++;\n        if(typeof exprOrFn == 'function'){\n            this.getter = exprOrFn; // 将用户传入的fn 保存在getter上\n        }else{\n            this.getter = () => vm[exprOrFn] // 取值的时候会收集watcher\n        }\n        this.depsId = new Set(); // 去重\n        this.value = this.get();\n        // this.value 就是老的值\n        this.callback = callback;\n        this.options = options\n    }\n    get() {\n        Dep.target = this; // 将watcher暴露到全局变量上\n        let value =  this.getter(); // 第一次渲染会默认调用getter  vm._update(vm._render())  // 取值的逻辑\n        Dep.target = null;\n        return value\n    }\n    addDep(dep) {\n        let id = dep.id;\n        if (!this.depsId.has(id)) {\n            this.depsId.add(id);\n            this.deps.push(dep); // 让watcher记住dep\n            dep.addSub(this)\n        }\n    }\n    update() {\n        console.log('update')\n        queueWatcher(this);\n    }\n    run() { // 真实的执行\n        let newValue = this.get();\n        let oldValue = this.value;\n        this.value = newValue;\n        if(this.options.user){\n            this.callback(newValue,oldValue)\n        }\n\n    }\n}\nlet watchsId = new Set();\nlet queue = [];\nlet pending = false;\nfunction flushShedulerQueue() {\n    for (let i = 0; i < queue.length; i++) {\n        let watcher = queue[i];\n        watcher.run();\n    }\n    queue = [];\n    watchsId.clear();\n    pending = false;\n}\n\nfunction queueWatcher(watcher) {\n    const id = watcher.id; // 取出watcher的id \n    if (!watchsId.has(id)) { // 看一下这里有没有这个watcher\n        watchsId.add(id); // 如果没有添加watcher到更新队列中\n        queue.push(watcher) // 放到队列中\n        if (!pending) {\n            // vue2 里面要考虑兼容性 vue2里面会优先采用promise但是ie不支持promise 需要降级成 mutationObserver h5提供的一个方法\n            // setImmediate 这个方法在ie中性能是比较好的，都不兼容fallback -> setTimeout\n            Promise.resolve().then(flushShedulerQueue);\n            pending = true\n        }\n    }\n}\nexport default Watcher","import { createElement, createTextElement } from \"./vdom/index.js\"\nimport { patch } from \"./vdom/patch.js\";\nimport Watcher from './observer/watcher'\n\nexport function lifeCycleMixin(Vue) {\n  Vue.prototype._update = function (vnode) { // 虚拟dom变成真实dom进行渲染的，后续更新也调用此方法\n    const vm = this;\n    let preVnode = vm._vnode; // 上一次的虚拟节点\n\n    vm._vnode = vnode;\n\n    if (!preVnode) {\n      // 首次渲染，传入一个真实的 dom 和 vnode\n      this.$el = patch(this.$el, vnode);\n    } else {\n      console.log(preVnode);\n      // 非首次渲染，传入两个 vnode，进行 dom diff\n      this.$el = patch(preVnode, vnode);\n    }\n  }\n  Vue.prototype._c = function () { // _c('div',undefoined,[])\n    return createElement(this, ...arguments)\n  }\n  Vue.prototype._v = function (text) { // _v(字符串 + name + 'xxx')\n    return createTextElement(this, text)\n  }\n  Vue.prototype._s = function (val) { // _s(name)\n    if (typeof val === 'object') return JSON.stringify(val);\n    return val;\n  }\n  Vue.prototype._render = function () { // 调用编译后的render方法，生成虚拟节点\n    const vm = this;\n    let { render } = vm.$options;\n    let vnode = render.call(vm); // 这里会进行取值操作 触发了get方法 仅需取值 （依赖收集）\n    return vnode\n  }\n}\nexport function mountComponent(vm, el) {\n  // vue3 里面靠的是产生一个effect, vue2中靠的是watcher\n  let updateComponent = () => {\n    // 1.产生虚拟节点 2.根据虚拟节点产生真实节点\n    vm._update(vm._render());\n  }\n  new Watcher(vm, updateComponent, () => {\n    callHook('beforeUpdate')\n  }); // 渲染是通过watcher来进行渲染的\n}\n\n// 和Vue3的渲染流程是否一致？","let oldArrayPrototype = Array.prototype;\nexport const proto = Object.create(oldArrayPrototype);\n\n// proto.__proto__ = oldArrayPrototype\n// arr.push()\n// 函数劫持 让vue中的数组 可以拿到重写后的原型，如果找不到调用数组本身的方法\n[\n    'push', 'pop', 'unshfit', 'shift', 'reverse', 'sort', 'splice'\n].forEach(method => {\n    proto[method] = function(...args) { // args 可能是对象，我们需要对新增的对象也增加劫持操作\n        // 调用老的方法\n        let r = oldArrayPrototype[method].call(this, ...args);\n        let ob = this.__ob__\n        let inserted;\n        // 我们需要对能新增的功能 再次做拦截 将新增的属性进行代理\n        switch (method) {\n            case 'push':\n            case 'unshift': // 前后新增\n                inserted = args\n                break;\n            case 'splice': // arr.splice(0,1,新增的内容)\n                inserted = args.slice(2)\n            default:\n                break;\n        }\n        // 找到数组的dep 让数组更新\n        // 我需要循环数组对他进行每一项的拦截\n        ob.dep.notify(); // 告诉用户该更新页面了\n\n        if(inserted)  ob.observeArray(inserted);\n        return r;\n    }\n})","import { proto } from \"./array\";\nimport Dep from './dep';\n\n// 这里需要让数组进行依赖收集 ，数组在页面中使用了，应该让数组收集watcher，调用push\\shuft\\unshift 方法应该触发数组的对应的watcher来更新\nclass Observer {\n    constructor(value) { // 将用户传入的选项 循环进行重写\n        this.dep = new Dep(); // 相当于给对象（数组、object）本身增加了一个dep属性\n        Object.defineProperty(value, '__ob__', {\n            enumerable: false, // 在后续的循环中不可枚举的属性不能被循环出来\n            value: this\n        })\n        if (Array.isArray(value)) {\n            // 重写数组的七个方法\n            value.__proto__ = proto;\n            // 如果数组里放的是对象 要对对象再次代理\n            this.observeArray(value);\n        } else {\n            this.walk(value);\n        }\n    }\n    walk(target) {\n        Object.keys(target).forEach(key => {\n            defineReactive(target, key, target[key]);\n        })\n    }\n    observeArray(target) {\n        for (let i = 0; i < target.length; i++) {\n            observe(target[i]);\n        }\n    }\n}\n\nfunction dependArray(value) {\n    for (let i = 0; i < value.length; i++) {\n        let c = value[i]; // [[[[[[[[]]]]]]]]\n        c.__ob__ && c.__ob__.dep.depend(); // 让数组中的对象或者数组再次依赖收集  [{name:'zzz'},[]]\n        if (Array.isArray(c)) {\n            dependArray(c); // 保证数组中的对象和数组都能有依赖收集的功能\n        }\n    }\n}\n\nfunction defineReactive(target, key, value) { // 定义响应式\n    let dep = new Dep(); // 这个dep属性是为了key来服务的\n    // 不存在的属性不会被defineProperty\n    let childOb = observe(value); // 递归对象类型检测 （性能差 默认情况下要对所有的都进行递归操作）\n\n    Object.defineProperty(target, key, { // 将属性重新定在对象上，增加了get和set（性能差）\n        get() {\n            // console.log('属性获取',36)\n            if (Dep.target) {\n                // 数组在页面中访问的方式也是通过实例来访问的 vm.arr, 也会执行对应的get方法， 让数组本身的dep收集这个watcher即可\n                dep.depend(); // 让属性对应的dep 记住当前的watcher， 我还需要让watcher记住dep ， 要去重\n                if (childOb) {\n                    childOb.dep.depend(); // 这个就是让对象本身和数组本身进行依赖收集\n                    // 还要对数组内部的对象也进行收集\n                    if (Array.isArray(value)) { // 因为数组里面可能有对象 可能里面是数组，那我需要让里面的数组也进行依赖收集 \n                        dependArray(value)\n                    }\n                }\n            }\n            return value;\n        },\n        set(newValue) {\n            if (newValue === value) return\n            // console.log('属性设置',41)\n            observe(newValue); // 设置的值如果是对象，那么就再次调用observe让对象变成响应式的\n            value = newValue;\n            dep.notify();\n        }\n    })\n}\n\nexport function observe(data) {\n    // data 就是我们用户传入的数据 我们需要对他进行观测\n    if (typeof data !== 'object' || data == null) {\n        return; // 不是对象不能观测\n    }\n    if (data.__ob__) { // 如果一个数据有__ob__ 属性 说明已经被观测过了\n        return;\n    }\n    // 后续要我们要知道是否这个对象被观测过了\n    return new Observer(data); // xxx instanceof Observer\n}","import { observe } from \"./observer/index.js\"; // rollup-plugin-rsolve\n\nexport function initState(vm) {\n    const options = vm.$options;\n    // 先props 在methods 在data 在 computed 在watch  (检测重名 规则是vue自己定的)\n    if (options.data) {\n        // 初始化data选项\n        initData(vm)\n    }\n    if (options.computed) {\n        // 计算属性的初始化\n        initComputed(vm)\n    }\n    if (options.watch) {\n        // 做一个watch选项的初始化\n        initWatch(vm)\n    }\n}\n\nfunction proxy(target, key, property) { // vm.xxx -> vm._data.xxx\n    Object.defineProperty(target, property, {\n        get() {\n            return target[key][property]\n        },\n        set(n) {\n            target[key][property] = n;\n        }\n    })\n}\n\nfunction initData(vm) {\n    let data = vm.$options.data;\n    // 需要对用户提供的data属性把他的所有属性进行重写增添get和set，只能拦截已经存在的属性\n    data = vm._data = typeof data === 'function' ? data.call(vm) : data; // vm._data 和 data是同一个对象，观测的是data 但是vm._data 也是被观测过的\n\n    // 用户使用 vm._data来获取有些麻烦， 我希望可以通过vm.xxx -> vm._data.xxx\n    for (let key in data) {\n        proxy(vm, '_data', key); // 循环代理属性, 为了用户使用的时候 直接可以通过vm.xxx\n    }\n    observe(data); // 对数据进行挂测\n}\n\nfunction initComputed(vm) {\n\n}\n\nfunction initWatch(vm) {\n    const watch = vm.$options.watch;\n    // 给每一个属性都创建一个watcher  （渲染watcher） （用户watcher） （计算属性watcher）\n    for(let key in watch){\n        createWatcher(vm,key,watch[key]);\n    }\n\n}\nexport function createWatcher(vm,key,value){\n    return vm.$watch(key,value); // 监控某个属性 和对应的处理函数\n}","// 1.合并 拷贝 面试问js 就问这俩 防抖节流柯里化\nconst strats = {};\n['beforeCreate', 'created', 'beforeMount', 'mounted'].forEach(method => {\n    strats[method] = function(parentVal,childVal) {\n        // 第一次 parentVal 是空的 Vue.options = {beforeCreate:function(){}} , options ={a,beforeCreate:function(){}}\n        if(childVal){\n            if(parentVal){\n                return parentVal.concat(childVal); // 父亲和儿子进行合并\n            }else{\n                return [childVal]; // 如果儿子有声明周期 父亲没有 就将儿子的变成数组\n            }\n        }else{\n            return parentVal; // 如果儿子没有就直接用父亲的\n        }\n    }\n})\nexport function mergeOptions(parentVal, childVal) { // 合并的过程是自己定义的策略\n    // 1.如果a的有b的没有，那么采用a的\n    // 2.如果a的有b的也有，那就采用b的\n    // 3.特殊情况 比如说生命周期，我就需要做处理把多个生命周期合并成数组\n    const options = {};\n    for (let key in parentVal) {\n        mergeField(key)\n    }\n    for (let key in childVal) { // b有的a没有\n        if (!parentVal.hasOwnProperty(key)) {\n            mergeField(key)\n        }\n    }\n    function mergeField(key) {\n        // 针对不同的key进行合并 ?, 将不同的策略定义在对象上，到时候根据不同的策略进行加载\n        if (strats[key]) {\n            options[key] = strats[key](parentVal[key], childVal[key]);\n        } else {\n            options[key] = childVal[key] || parentVal[key]; // 新的有优先用新的\n        }\n    }\n    return options;\n}","import { compileToFunction } from \"./compile/index.js\";\nimport { mountComponent } from \"./lifecycle.js\";\nimport Watcher from \"./observer/watcher.js\";\nimport { createWatcher, initState } from \"./state\";\nimport { mergeOptions } from \"./utils.js\";\n\nfunction callHook(vm,hook){ // 找到对应的处理函数依次执行\n    const handlers = vm.$options[hook];\n    if(handlers){\n        for(let i = 0; i < handlers.length;i++){\n            handlers[i].call(vm);\n        }\n    }\n}\nexport function initMixin(Vue) {\n    Vue.prototype._init = function(options) {\n        const vm = this;\n        // 此时options 是用户的 我需要用用户的+全局的 合并出结果来\n        vm.$options = mergeOptions(this.constructor.options,options); // 后续所有的原型中都可以通过 vm.$options 拿到用户传递的选项\n\n        callHook(vm,'beforeCreate');\n\n        initState(vm); // 状态的初始化，目的就是初始化用户传入的props  data  computed watch\n        // 判断用户是否传入了el ，如果传入了el 要实现页面的挂载\n        if(options.el){\n            vm.$mount(options.el);\n        }\n    }   \n    Vue.prototype.$mount = function(el){\n        // render -> template -> outerHTML\n        const vm = this;\n        el  = document.querySelector(el);\n        vm.$el = el;\n        const options = vm.$options;\n        let render;\n        if(!options.render){\n            // 没有render\n            let template = options.template;\n            if(!template){  // 如果没有模板 就采用指定元素对应的模板\n                template = el.outerHTML\n            }\n            options.render = compileToFunction(template); // 模板的编译\n        }\n        // 有render直接调用render方法\n        // render = options.render;  // 最终拿到编译后的render\n\n        // 根据render方法产生虚拟节点，在将虚拟节点变成真实节点 插入到页面中即可\n        mountComponent(vm,el)// 组件挂载流程 \n    }\n    Vue.prototype.$watch = function(key,handler){\n       const watcher =  new Watcher(this,key,handler,{user:true});\n    }  \n}","import { mergeOptions } from \"../utils\";\n\nexport function initGlobalAPI(Vue) {\n    Vue.options = {}; // 所有的全局属性 都会放到这个变量上\n    Vue.mixin = function(options) { // 用户要合并的对象\n        this.options = mergeOptions(this.options, options)\n    }\n}\n","import { compileToFunction } from \"./compile\";\nimport { initMixin } from \"./init\";\nimport { initGlobalAPI } from \"./initGlobalAPI/index\";\nimport { lifeCycleMixin } from \"./lifecycle\";\nimport { createElm, patch } from \"./vdom/patch\";\n\n// 给Vue的构造函数 扩展原型方法， 还会扩展一些静态方法\nfunction Vue(options){ // 构造函数\n    this._init(options)\n}\ninitGlobalAPI(Vue)\ninitMixin(Vue);\nlifeCycleMixin(Vue);\nexport default Vue;\n\n\n// 1. 当new Vue的时候都发生了什么, 默认会进行vue的初始化操作 _init(), 后面组件的初始化也会调用_init\n// optionsApi 不知道这些选项哪些能用到  所以无法实现tree-shaking\n\n\n// const template1 = `<ul a=1>\n// <li style=\"background:red\" key=\"A\">A</li>\n// <li style=\"background:yellow\" key=\"B\">B</li>\n// <li style=\"background:green\" key=\"C\">C</li>\n// <li style=\"background:purple\" key=\"D\">D</li>\n// </ul>`\n\n// // 手动将模板渲染成render函数 \n// const render1 = compileToFunction(template1);\n// const vm1 = new Vue({ data: {} })\n// let oldVnode = render1.call(vm1); // 虚拟节点\n\n// const el1 = createElm(oldVnode); // 产生了一个真实的节点\n// document.body.appendChild(el1);\n\n\n// // 更新会再次生成ast？ 只会重新生成一次， 产生一个render函数，render函数根据不同的数据渲染内容 （render函数返回的前后虚拟节点可能是不一样的，所以我们需要做一个diff算法）\n// const template2 = `<ul a=2>\n// <li style=\"background:yellow\" key=\"B\">B</li>\n// <li style=\"background:purple\" key=\"D\">D</li>\n// <li style=\"background:red\" key=\"E\">E</li>\n// <li style=\"background:purple\" key=\"M\">M</li>\n// <li style=\"background:green\" key=\"P\">P</li>\n// </ul>`\n// const render2 = compileToFunction(template2);\n// let newVnode = render2.call(vm1); // 虚拟节点\n\n// setTimeout(() => {\n//     // 产生了一个真实的节点\n//     patch(oldVnode, newVnode)\n// }, 1000);\n\n\n"],"names":["defaultTagRE","genProps","attrs","str","i","length","attr","name","style","value","replace","arguments","JSON","stringify","slice","gen","el","type","generate","text","test","tokens","match","lastIndex","exec","index","push","trim","join","genChildren","ast","children","map","child","code","tag","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parserHTML","html","advance","len","substring","parseStartTag","start","tagName","end","root","stack","createAstElement","parent","element","chars","pop","textEnd","indexOf","startTagMatch","endTagMatch","compileToFunction","render","Function","createElement","vm","props","vnode","undefined","key","createTextElement","isSameVnode","oldVnode","newVnode","patch","nodeType","parentElm","parentNode","elm","createElm","insertBefore","nextSibling","removeChild","patchVnode","replaceChild","textContent","updateProperties","oldChildren","newChildren","updateChildren","innerHTML","forEach","appendChild","oldStartIndex","newStartIndex","oldEndIndex","newEndIndex","oldStartVnode","newStartVnode","oldEndVnode","newEndVnode","makeIndexByKey","item","moveIndex","moveVnode","anchor","oldProps","newProps","oldStyle","newStyle","removeAttribute","styleName","setAttribute","document","createTextNode","id","Dep","subs","target","addDep","watcher","update","Watcher","exprOrFn","callback","options","deps","getter","depsId","Set","get","dep","has","add","addSub","console","log","queueWatcher","newValue","oldValue","user","watchsId","queue","pending","flushShedulerQueue","run","clear","Promise","resolve","then","lifeCycleMixin","Vue","prototype","_update","preVnode","_vnode","$el","_c","_v","_s","val","_render","$options","call","mountComponent","updateComponent","callHook","oldArrayPrototype","Array","proto","Object","create","method","args","r","ob","__ob__","inserted","notify","observeArray","Observer","defineProperty","enumerable","isArray","__proto__","walk","keys","defineReactive","observe","dependArray","c","depend","childOb","set","data","initState","initData","computed","watch","initWatch","proxy","property","n","_data","createWatcher","$watch","strats","parentVal","childVal","concat","mergeOptions","mergeField","hasOwnProperty","hook","handlers","initMixin","_init","constructor","$mount","querySelector","template","outerHTML","handler","initGlobalAPI","mixin"],"mappings":"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"}